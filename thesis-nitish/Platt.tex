\chapter{Probabilistic Outputs for SVM}
\label{appendix:SVMProb}
The following is the improved code by \citep{Lin03Note} for the algorithm proposed originally by \citep{Platt99}, that theoretically converges and avoids numerical difficulties.

\begin{verbatim}

Input parameters:
  deci = array of SVM decision values
  label = array of booleans: is the example labeled +1?
  prior1 = number of positive examples
  prior0 = number of negative examples
Outputs:
  A, B = parameters of sigmoid
  
//Parameter setting
maxiter=100
//Maximum number of iterations
minstep=1e-10
//Minimum step taken in line search
sigma=1e-12
//Set to any value > 0
//Construct initial values: target support in array t,
//initial function value in fval
hiTarget=(prior1+1.0)/(prior1+2.0), loTarget=1/(prior0+2.0)
len=prior1+prior0 // Total number of data
for i = 1 to len {
    if (label[i] > 0)
        t[i]=hiTarget
    else
        t[i]=loTarget
}
A=0.0, B=log((prior0+1.0)/(prior1+1.0)), fval=0.0
for i = 1 to len {
    fApB=deci[i]*A+B
    if (fApB >= 0)
        fval += t[i]*fApB+log(1+exp(-fApB))
    else
        fval += (t[i]-1)*fApB+log(1+exp(fApB))
}
for it = 1 to maxiter {
    //Update Gradient and Hessian (use H’ = H + sigma I)
    h11=h22=sigma, h21=g1=g2=0.0
    for i = 1 to len {
        fApB=deci[i]*A+B
        if (fApB >= 0)
            p=exp(-fApB)/(1.0+exp(-fApB)), q=1.0/(1.0+exp(-fApB))
        else
            p=1.0/(1.0+exp(fApB)), q=exp(fApB)/(1.0+exp(fApB))
        d2=p*q
        h11 += deci[i]*deci[i]*d2, h22 += d2, h21 += deci[i]*d2
        d1=t[i]-p
        g1 += deci[i]*d1, g2 += d1
    }
    if (abs(g1)<1e-5 && abs(g2)<1e-5) //Stopping criteria
        break
    //Compute modified Newton directions
    det=h11*h22-h21*h21
    dA=-(h22*g1-h21*g2)/det, dB=-(-h21*g1+h11*g2)/det
    gd=g1*dA+g2*dB
    stepsize=1
    while (stepsize >= minstep){ //Line search
        newA=A+stepsize*dA, newB=B+stepsize*dB, newf=0.0
        for i = 1 to len {
            fApB=deci[i]*newA+newB
            if (fApB >= 0)
                newf += t[i]*fApB+log(1+exp(-fApB))
            else
                newf += (t[i]-1)*fApB+log(1+exp(fApB))
        }
        if (newf<fval+0.0001*stepsize*gd){
            A=newA, B=newB, fval=newf
            break //Sufficient decrease satisfied
        }
        else
            stepsize /= 2.0
    }
    if (stepsize < minstep){
        print ’Line search fails’
        break
    }
}
if (it >= maxiter)
    print ’Reaching maximum iterations’
return [A,B]
\end{verbatim}
